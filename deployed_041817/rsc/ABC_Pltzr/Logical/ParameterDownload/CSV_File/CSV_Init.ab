FUNCTION_BLOCK CSV_Init
;*****************************************************************
;FUB: 			CSV_Init
;*****************************************************************
;Discription:
;	This FUB count the neccessary memory, to save the CSV-File on the SPS
;	For the count, the FUB simulate the creation of a CSV-File
;
;Parameter:
;
;Author:	Georg Kreil
;			B&R Eggelsberg
;
;History:	V0.01 - 17 June 2003
;					created
;			V0.01.1 - 4 July 2003
;					Error with return-jumps by Array-structures corrected
;			V0.01.2 - 8 July 2003
;					Error arrays about index 9 corrected
;			V0.01.3 - 14 July 2003
;					no changes
;			V0.01.4 - 15 July 2003
;					no changes
;			V0.01.5 - 17 July 2003
;					Error, when variable starts with array-structure, corrected
;			V0.01.6 - 21 July 2003
;					no changes
;			V0.01.7 - 7 August 2003
;					no changes
;			V0.01.8 - 8 August 2003
;					no changes
;			V0.01.9 - 11 August 2003
;					Error with return-jumps by Array-structures corrected
;			V0.02   - 10 September 2003
;					Error with Arrays (111 instead of 11) corrected
;			V0.02.1 - 11 September 2003
;					functionality added
;						- full variablename saving possible
;						- no header possible
;			V0.02.2	- 26 September 2003
;					more structures in one file
;			V0.02.9	- 28 November 2003
;					fullname by array's error corrected
;			V0.03.1 - 26 January 2004
;					multiple array-structure
;			V0.03.2 - 5 May 2004
;				  single variable corrected
;			V0.03.5 - 30 May 2004
;					part of sturcture possible
;
;*****************************************************************
Options = Options


if (pStructName <> 0) then

	Internal.Ebene= 1	;Start-Level
	MemCounter= 1000     ;Maximum-Size of the Header
	OnlyOneVar= 0

	loop Internal.i=0 to 49 do
		Internal.ItemNrSoll[Internal.i]= 65535	;set and reset internal counter
		Internal.ItemNrIst[Internal.i]= 0
	endloop
	; Carriage Return and Linefeed
	Internal.CRLF[0]= 13
	Internal.CRLF[1]= 10
	Internal.CRLF[2]= 0		; String Zerotermination

	Dyn_Udint access pStructName
	if(Dyn_Udint <> 0 )then
		strcpy( adr(Internal.VarItemName),Dyn_Udint )	;copy Structurename to Internal "Work"-String

		loop Internal.i=usint(strlen(adr(Internal.VarItemName)+1)) downto 0 do
			SearchChar access adr(Internal.VarItemName) + Internal.i	; set dynamic variable for access
				if (SearchChar = '.')then
					Internal.ItemNrSoll[Internal.Ebene]= 1
					Internal.ItemNrIst[Internal.Ebene]= 1
					Internal.Ebene= Internal.Ebene+1
				else if(SearchChar = '[') then
					Internal.ItemNrSoll[Internal.Ebene]= 1
					Internal.ItemNrIst[Internal.Ebene]= 1
					Internal.Ebene= Internal.Ebene+1
				endif
		endloop
	endif

	; Variablenzähler zurücksetzen
	Internal.VariableCounter = 0

	Internal.NameCounter= 1

	loop	;!!!!ATTENTION!!!! endless loop
			; in the cyclic part of a Task are Cycletime-Violation possible

	select Internal.Step

		;##########################################################################################
		state PV_INFO
		;##########################################################################################
			when (Dyn_Udint = 0 ) do
				status= ERROR_STRUCT_NAMES
				ErrorName= Internal.NameCounter
			next WAIT

		; save the startname of the variable
			strcpy( adr(Internal.StartVarName), adr(Internal.VarItemName) )

		; get Information about the Structure
			Internal.PV_ninfoStatus = PV_ninfo(adr(Internal.VarItemName), adr(Internal.Datatyp), adr(Internal.DataLenght), adr(Internal.Dimension))
			Internal.PV_xgetadrStatus = PV_xgetadr(adr(Internal.VarItemName), adr(Internal.PV_Adress), adr(Internal.Lenght))

			when (Internal.PV_ninfoStatus <> 0) do	; any error ocurred
				status= Internal.PV_ninfoStatus		; return error-code
				ErrorName= Internal.NameCounter
			next WAIT

			; handling of "normal" structure, part of name
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 0) and (FullNameLenght = 0) do 	; no error and datatyp is "STRUCTURE"
				strcpy(adr(Internal.StrukturName),adr(Internal.CRLF[0]))		; new line
				strcat(adr(Internal.StrukturName),adr(Internal.VarItemName))	; enter structure name
				strcat(adr(Internal.StrukturName),";STRUCTURE")					; enter as datatyp "STRUCTURE"
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))		; new line
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension		; save number of dimensions
				status= 65535
			next COUNT_OFFSET_HEADER

			; handling of "normal" structures , full name
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 0) and (FullNameLenght = 1) do 	; no error and datatyp is "STRUCTURE"
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension		; save number of dimensions
				status= 65535
			next PV_ITEM

			; handling of array's (no array structures), part of name
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.Dimension > 1) and (FullNameLenght = 0) do
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1		; save number of dimensions
				strcpy(adr(Internal.StrukturName),adr(Internal.CRLF[0]))		; new line
				strcat(adr(Internal.StrukturName),adr(Internal.VarItemName))	; enter structure name
				strcat(adr(Internal.StrukturName),";ARRAY")						; enter as datatyp "ARRAY"
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))		; new line

				; create the right name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")							; test_var[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))	; convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))			; test_var[0
				strcat(adr(Internal.VarItemName),"]")							; test_var[0]

				Internal.ArrayVariable= 1										; flag for array-variable
				status= 65535
			next COUNT_OFFSET_HEADER

			; handling of array's (no array structures), full name
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.Dimension > 1) and (FullNameLenght = 1) do
				; create the right name for the next PV-function
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1		; save number of dimensions
				strcat(adr(Internal.VarItemName),"[")							; test_var[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))	; convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))			; test_var[0
				strcat(adr(Internal.VarItemName),"]")							; test_var[0]
				Internal.ArrayVariable= 1										; flag for array-variable
				status= 65535
			next PV_ITEM_INFO

			; handling of array-structures, part of name
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 15) and (FullNameLenght = 0) do

				strcpy(adr(Internal.StrukturName),adr(Internal.CRLF[0]))		; new line
				strcat(adr(Internal.StrukturName),adr(Internal.VarItemName))	; enter structure name
				strcat(adr(Internal.StrukturName),";ARRAY_OF_STRUCTURES")		; enter as datatyp "ARRAY_OF_STRUCTURES"
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))		; new line

				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1		; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0							; reset dimension-counter

				; create the right name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")							; test_var[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))	; convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))			; test_var[0
				strcat(adr(Internal.VarItemName),"]")							; test_var[0]
				Internal.ArrayStructure= 1										; flag for array-structures
				status= 65535
			next COUNT_OFFSET_HEADER

			; handling of array-structures, full name
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 15) and (FullNameLenght = 1) do
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1		; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0							; reset dimension-counter

				; create the right name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")							; test_var[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))	; convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))			; test_var[0
				strcat(adr(Internal.VarItemName),"]")							; test_var[0]
				Internal.ArrayStructure= 1										; flag for array-structures
				status= 65535
			next PV_ITEM_INFO

			; handling of the other datatyp's (USINT,BOOL,...)
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.Dimension <= 1) do
				strcpy(adr(Internal.StrukturName),adr(Internal.VarItemName))		; enter variable name
				Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene] + 1 	;increase dimension-counter
				Internal.ItemNrSoll[Internal.Ebene]= Internal.Dimension				; save number of dimensions
				OnlyOneVar= 1
				status= 65535
			next PV_DATATYP

		;##########################################################################################
		state COUNT_OFFSET_HEADER
		;##########################################################################################
		; count the neccessary memory for this row in the CSV-File

			when ( (Internal.Datatyp = 15) or ((Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.Dimension > 1) )) do
				MemCounter= MemCounter + strlen(adr(Internal.StrukturName))-1 	; count the neccessary memory for this row in the CSV-File
				strcpy(adr(Internal.StrukturName),"")			; erase the counted row
				loop Internal.i=0 to Internal.Ebene do			; create the spaces for the next line
					strcat(adr(Internal.StrukturName),"     ")
				endloop
				strcat(adr(Internal.StrukturName),".")			; add the point for the next name
				status= 65535
			next PV_ITEM_INFO

			when ( (Internal.Datatyp = 0) or (Internal.Dimension <= 1) )do
				MemCounter= MemCounter + strlen(adr(Internal.StrukturName))-1	; count the neccessary memory for this row in the CSV-File
				strcpy(adr(Internal.StrukturName),"")			; erase the counted row
				loop Internal.i=0 to Internal.Ebene do 			; create the spaces for the next line
					strcat(adr(Internal.StrukturName),"     ")
				endloop
				strcat(adr(Internal.StrukturName),".")			; add the point for the next name
				status= 65535
			next PV_ITEM

		;##########################################################################################
		state PV_ITEM
		;##########################################################################################
		;	get the name of the next Item in the structure
			Internal.PV_itemStatus = PV_item(adr(Internal.VarItemName), Internal.ItemNrIst[Internal.Ebene],adr(Internal.ItemName))

			; create name for the next PV-function
			when (Internal.PV_itemStatus = 0) do				; no error
				strcat(adr(Internal.VarItemName),".")			; add the point for the next name (teststructure -> teststructure.)
				strcat(adr(Internal.VarItemName),adr(Internal.ItemName))	; add the itemname (teststructure. -> teststructure.itemname)
				Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene] + 1	; increase the dimension-counter
				status= 65535
			next PV_ITEM_INFO

			when (Internal.PV_itemStatus <> 0) do	; any error ocurred
				status= Internal.PV_ninfoStatus		; return error-code
				ErrorName= Internal.NameCounter
			next WAIT

		;##########################################################################################
		state PV_ITEM_INFO
		;##########################################################################################

			Internal.PV_ninfoStatus = PV_ninfo(adr(Internal.VarItemName), adr(Internal.Datatyp), adr(Internal.DataLenght), adr(Internal.Dimension))
			Internal.PV_xgetadrStatus = PV_xgetadr(adr(Internal.VarItemName), adr(Internal.PV_Adress), adr(Internal.Lenght))

			; for part of structure: control, if this is the correct part
			when ( memcmp(adr(Internal.VarItemName), adr(Internal.StartVarName), strlen(adr(Internal.StartVarName))) <> 0) do
				status= 65535
			next ALLOC_MEMORY

	;		###############################
	;		Correction from 17 July 2003
			when ( (Internal.PV_ninfoStatus <> 0 ) and (Internal.PV_xgetadrStatus <> 0) ) and ( Internal.ItemNrIst[1] > Internal.ItemNrSoll[1] ) do
				status= 65535
			next ALLOC_MEMORY
	;		Correction from 17 July 2003
	;		###############################

			when (Internal.PV_ninfoStatus <> 0) do		; any error ocurred
				status= Internal.PV_ninfoStatus			; return error-code
				ErrorName= Internal.NameCounter
			next WAIT

			when (Internal.PV_xgetadrStatus <> 0) do	; any error ocurred
				status= Internal.PV_xgetadrStatus		; return error-code
				ErrorName= Internal.NameCounter
			next WAIT

			;******************************************************************************************
			; a new structure/dimension was found (only last Part of PV-Name)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 0)  and (Internal.ArrayStructure = 0) and (FullNameLenght = 0) do
				strcat(adr(Internal.StrukturName),adr(Internal.ItemName))	; add the new item-name to the CSV-file
				inc(Internal.Ebene) 										; increase the dimension-counter
				Internal.ItemNrSoll[Internal.Ebene]= Internal.Dimension		; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter
				status= 65535
			next PV_DATATYP

			;******************************************************************************************
			; a new structure/dimension was found ( whole PV-Name)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 0)  and (Internal.ArrayStructure = 0) and (FullNameLenght = 1) do
				inc(Internal.Ebene) 										; increase the dimension-counter
				Internal.ItemNrSoll[Internal.Ebene]= Internal.Dimension		; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter
				status= 65535
			next PV_ITEM_LOOP

			;******************************************************************************************
			; a new structure/dimension was found in an array-structure, part of Name
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 0) and (Internal.ArrayStructure = 1) and (FullNameLenght = 0) do
				strcpy(adr(Internal.ItemName),adr(Internal.VarItemName))	; copy variable-name
				Internal.FoundChar= 1										; set counter for found levels
																			;	-> '.''[' are character for levels
				; loop to the rearmost '.' in the variable-name
				loop Internal.i=usint(strlen(adr(Internal.ItemName)+1)) downto 0 do
					SearchChar access adr(Internal.ItemName) + Internal.i	; set dynamic variable for access
					exitif(SearchChar ='.')									; exit from loop
				endloop
	;			###############################
	;			Correction from 17 July 2003
				if( Internal.i = 0) then
					strcat( adr(Internal.StrukturName), adr(Internal.ItemName)+Internal.i )
				else
					strcat(adr(Internal.StrukturName),adr(Internal.ItemName)+Internal.i+1)
				endif

	;			strcat(adr(Internal.StrukturName),adr(Internal.ItemName)+Internal.i+1)	; add the variable-name to the CSV-File from the found '.'
	;			Correction from 17 July 2003
	;			###############################

				inc(Internal.Ebene) 										; increase level-counter
				Internal.ItemNrSoll[Internal.Ebene]= Internal.Dimension		; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter
				status= 65535
			next PV_DATATYP

			;******************************************************************************************
			; a new structure/dimension was found in an array-structure	,full name
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 0) and (Internal.ArrayStructure = 1) and (FullNameLenght = 1) do
				strcpy(adr(Internal.ItemName),adr(Internal.VarItemName))	; copy variable-name
				Internal.FoundChar= 1										; set counter for found levels
																			;	-> '.''[' are character for levels
				; loop to the rearmost '.' in the variable-name
				loop Internal.i=usint(strlen(adr(Internal.ItemName)+1)) downto 0 do
					SearchChar access adr(Internal.ItemName) + Internal.i	; set dynamic variable for access
					exitif(SearchChar ='.')									; exit from loop
				endloop

				inc(Internal.Ebene) 										; increase level-counter
				Internal.ItemNrSoll[Internal.Ebene]= Internal.Dimension		; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter
				status= 65535
			next PV_DATATYP

			;******************************************************************************************
			; array-variable was found ( no array-structure, full Name)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.Dimension > 1) and (FullNameLenght = 1) do

				inc(Internal.Ebene)											; increase the level-counter
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1	; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter

				;create new variable-name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")						; add to the variable-name '[' ->testvariable[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index)); convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index ->testvariable[0
				strcat(adr(Internal.VarItemName),"]")						; add ']' ->testvariable[0]
				Internal.ArrayVariable= 1									; flag for array-variable
				status= 65535
			next PV_ITEM_INFO

			;******************************************************************************************
			; array-variable was found ( no array-structure, part of name)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.Dimension > 1) and (FullNameLenght = 0) do

				inc(Internal.Ebene)											; increase the level-counter
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1	; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter

				; create entry in the CSV-file
				strcat(adr(Internal.StrukturName),adr(Internal.ItemName))	; add the new item-name to the CSV-file
				strcat(adr(Internal.StrukturName),";ARRAY")					; add as datatyp "ARRAY"
				strcat(adr(Internal.StrukturName),"[")						; add '[' -> ARRAY[
				itoa(Internal.Dimension,adr(Internal.Index))
				strcat(adr(Internal.StrukturName),adr(Internal.Index))		; add index	-> ARRAY[0
				strcat(adr(Internal.StrukturName),"];")						; add']' -> ARRAY[0]
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))	; new line

				;create new variable-name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")						; add to the variable-name '[' ->testvariable[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index)); convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index ->testvariable[0
				strcat(adr(Internal.VarItemName),"]")						; add ']' ->testvariable[0]
				Internal.ArrayVariable= 1									; flag for array-variable
				status= 65535
			next COUNT_OFFSET

			;******************************************************************************************
			; array-structure was found (part of name )
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 15) and (FullNameLenght = 0) do

				strcat(adr(Internal.StrukturName),adr(Internal.ItemName))	; add the new item-name to the CSV-file
				inc(Internal.Ebene)											; increase level-counter
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1	; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter

				;create new variable-name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")						; add to the variable-name '[' ->testvariable[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index)); convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index ->testvariable[0
				strcat(adr(Internal.VarItemName),"]")						; add ']' ->testvariable[0]
				Internal.ArrayStructure= 1									; flag for array-structure
				status= 65535
			next PV_DATATYP

			;******************************************************************************************
			; array-structure was found (full name)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp = 15) and (FullNameLenght = 1) do

				inc(Internal.Ebene)											; increase level-counter
				Internal.ItemNrSoll[Internal.Ebene] = Internal.Dimension-1	; save number of dimensions
				Internal.ItemNrIst[Internal.Ebene]= 0						; reset dimension-counter

				;create new variable-name for the next PV-function
				strcat(adr(Internal.VarItemName),"[")						; add to the variable-name '[' ->testvariable[
				itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index)); convert index-number to index-string
				strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index ->testvariable[0
				strcat(adr(Internal.VarItemName),"]")						; add ']' ->testvariable[0]
				Internal.ArrayStructure= 1									; flag for array-structure
				status= 65535
			next PV_ITEM_INFO

			;******************************************************************************************
			; there was no new structure/dimension found, but in this level, there are more as one other dimensions(elements)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and ((Internal.Datatyp <> 0) or (Internal.Datatyp <> 15)) and (Internal.ItemNrIst[Internal.Ebene] < Internal.ItemNrSoll[Internal.Ebene]) and (Internal.Dimension <= 1)do

				if (FullNameLenght = 1) then
					strcpy( adr(Internal.FullStrukturName), adr(Internal.VarItemName) )
				endif

				Internal.FoundChar= 1 			; set counter for found levels
				loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do	; loop the hole variable name
					SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamic variable access

					;******************************************************************************************
					; the right level was found
					;******************************************************************************************
					if( (SearchChar = '.') and (Internal.FoundChar = Internal.Ebene) )then
						strcat(adr(Internal.StrukturName),adr(Internal.ItemName))	; add the new item-name to the CSV-file
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						exitif(1=1)			; exit loop
					;******************************************************************************************
	 				; an array-variable was found in the right level (no array's in structure)
					;******************************************************************************************
	 				else if( (SearchChar = '[') and (Internal.FoundChar = Internal.Ebene) and (Internal.Ebene = 1) )then	; es ist noch die richtige Internal.Ebene erreicht
						strcat(adr(Internal.StrukturName),adr(Internal.VarItemName))
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1	; increase dimension-counter
						itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
						strcat(adr(Internal.VarItemName),"[")					; add to the variable-name '[' ->testvariable[
						strcat(adr(Internal.VarItemName),adr(Internal.Index))	; add index ->testvariable[0
						strcat(adr(Internal.VarItemName),"]")					; add ']' ->testvariable[0]
						Internal.ArrayVariable= 1								; flag for array-structure
						exitif(1=1)
					;******************************************************************************************
					; an array was found in the right level
					;******************************************************************************************
	 				else if( (SearchChar = '[') and (Internal.FoundChar = Internal.Ebene) and (Internal.Ebene > 1) )then
						loop Internal.i=Internal.Merker to  usint(strlen(adr(Internal.VarItemName)+1)) do
							SearchChar access adr(Internal.VarItemName) + Internal.i		; dynamic variable access
							Internal.ArrayName[Internal.i-Internal.Merker]= SearchChar		; copy the last item-name
						endloop
						Internal.ArrayName[Internal.i-Internal.Merker+1]= 0					; zero-termination of the copied name
						strcat(adr(Internal.StrukturName),adr(Internal.ArrayName))			; add the copied name to the CSV-file
						SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamic variable access
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1	; increase dimension-counter
						itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
						strcat(adr(Internal.VarItemName),"[")								; add to the variable-name '[' ->testvariable[
						strcat(adr(Internal.VarItemName),adr(Internal.Index))				; add index ->testvariable[0
						strcat(adr(Internal.VarItemName),"]")								; add ']' ->testvariable[0]
						Internal.ArrayVariable= 1											; flag for array-structure
						exitif(1=1)									; exit loop
					;******************************************************************************************
					; a level was found, but not the right level
					;******************************************************************************************
					else if( ((SearchChar = '.') or(SearchChar = ']') ) and (Internal.FoundChar < Internal.Ebene) )then
						inc(Internal.FoundChar)						; increase counter for found levels
						Internal.Merker= Internal.Counter_Usint+1	; notice position of the found level-character
					endif
				endloop
				status= 65535
			next PV_DATATYP

			;******************************************************************************************
			; there was no new structure/dimension found, but in this level, there is only one other dimensions(elements)
			;******************************************************************************************
			when (Internal.PV_ninfoStatus = 0) and (Internal.Datatyp <> 0) and (Internal.Datatyp <> 15) and (Internal.ItemNrIst[Internal.Ebene] >= (Internal.ItemNrSoll[Internal.Ebene]))do

				if (FullNameLenght = 1) then
					strcpy( adr(Internal.FullStrukturName), adr(Internal.VarItemName) )
				endif

				Internal.FoundChar= 1 		; set counter for found levels
				loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do	; loop the hole variable name
					SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamic variable access
					;******************************************************************************************
					; the right level was found
					;******************************************************************************************
					if ( (SearchChar = '.') and ( (Internal.FoundChar = Internal.Ebene) or (Internal.FoundChar = (Internal.Ebene-1)) )  and (Internal.ArrayVariable = 0) and (Internal.ArrayStructure = 0) )then	; es ist noch die richtige Internal.Ebene erreicht
						strcat(adr(Internal.StrukturName),adr(Internal.ItemName))
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						if(Internal.Ebene <> 0)then
							Internal.Ebene= Internal.Ebene - 1	; reduce level-counter
						else
							Internal.Ebene= 0					; set level-counter to zero
						endif
						exitif(1=1)			; exit loop

					;******************************************************************************************
					; structure with array-structure found
					;******************************************************************************************
					else if ( (SearchChar = '.') and  (Internal.FoundChar = Internal.Ebene-1)  and (Internal.ArrayVariable = 0) and (Internal.ArrayStructure = 1) )then	; es ist noch die richtige Ebene erreicht
						strcat(adr(Internal.StrukturName),adr(Internal.ItemName))	; add the new item-name to the CSV-file
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						if(Internal.Ebene <> 0)then
	;					###############################
	;					Correction from 4 July 2003
	;						Internal.Ebene= Internal.Ebene - 1	; reduce level-counter
							loop Internal.Ebene=Internal.Ebene-1 downto 0 do
								exitif((Internal.ItemNrIst[Internal.Ebene] < Internal.ItemNrSoll[Internal.Ebene]))
							endloop


							if(Internal.MerkerArray[Internal.Ebene]= 1)then
								Internal.FoundChar= 0
								loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
									SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamischen Variable setzen

									if ( (SearchChar = '[') and (Internal.Ebene-1 = Internal.FoundChar) )then
										SearchChar= 0
										Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1
										strcat(adr(Internal.VarItemName),"[")
										itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
										strcat(adr(Internal.VarItemName),adr(Internal.Index))
										strcat(adr(Internal.VarItemName),"]")
										Internal.NextItemReady= 1
										loop Internal.i=usint(strlen(adr(Internal.VarItemName)+1)) downto 0 do
											SearchChar access adr(Internal.VarItemName) + Internal.i		; dynamischen Variable setzen
											exitif(SearchChar='.')
										endloop

	;					###############################
	;					Correction from 11 August 2003
										if (Internal.i = 0) then
											strcpy(adr(Internal.ItemName),adr(Internal.VarItemName) + Internal.i)
										else
											strcpy(adr(Internal.ItemName),adr(Internal.VarItemName) + Internal.i + 1)
										endif
	;					Correction from 11 August 2003
	;					###############################
										exitif(1=1)
									else if	( (SearchChar = '[') and (Internal.Ebene > Internal.FoundChar) )then
										inc(Internal.FoundChar)		; eine weitere Ebene gefunden
									else if( (SearchChar = '.') and (Internal.Ebene > Internal.FoundChar) )then
										inc(Internal.FoundChar)		; eine weitere Ebene gefunden
									endif
								endloop
							else
								Internal.FoundChar= 0
								loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
									SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamischen Variable setzen

									if ( (SearchChar = '.') and (Internal.Ebene-1 = Internal.FoundChar) )then
										SearchChar= 0
										exitif(1=1)
									else if	( (SearchChar = '[') and (Internal.Ebene > Internal.FoundChar) )then
										inc(Internal.FoundChar)		; eine weitere Ebene gefunden
									else if( (SearchChar = '.') and (Internal.Ebene > Internal.FoundChar) )then
										inc(Internal.FoundChar)		; eine weitere Ebene gefunden
									endif
								endloop
							endif
	;					Correction from 4 July 2003
	;					###############################
						else
							Internal.Ebene= 0					; set level-counter to zero
						endif
						Internal.ArrayStructure= 0				; reset flag for array-structure
						exitif(1=1)			; exit loop

					;******************************************************************************************
					; the array-sturcture is not on the end, there are another array-indexes available
					;******************************************************************************************
					else if ( (SearchChar = '.') and (Internal.FoundChar = Internal.Ebene) and (Internal.ItemNrIst[Internal.Ebene-1] < Internal.ItemNrSoll[Internal.Ebene-1]) and (Internal.ArrayVariable = 0) and (Internal.ArrayStructure = 1) )then

	;					###############################
	;					Correction from 8 July 2003
						strcat(adr(Internal.StrukturName),adr(Internal.ItemName))	; add the new item-name to the CSV-file

						; set the counter to the index in the variablename, to set here the zerotemination
						; e.g.: test.var1.structure[0].value -> test.var1.structure[
						loop Internal.i=Internal.Counter_Usint-1 downto 0 do
							SearchChar access adr(Internal.VarItemName) + Internal.i ; dynamic variable access
							exitif(SearchChar = '[')
						endloop

						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						Internal.Ebene= Internal.Ebene - 1	;reduce level-counter
						strcat(adr(Internal.VarItemName),"[")						; add '[' -> test.var1.structure[
	;					Correction from 8 July 2003
	;					###############################

						Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1 ; increase dimension-counter
						itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
						strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index to the variable-name e.g.: test.var1.structure[
																					; -> test.var1.structure[0
						strcat(adr(Internal.VarItemName),"]")						; add ']' -> test.var1.structure[0]
						exitif(1=1)			; exit loop

					;******************************************************************************************
					; the array-sturcture is on the end
					;******************************************************************************************
					else if ( (SearchChar = '.') and (Internal.FoundChar = Internal.Ebene) and (Internal.ItemNrIst[Internal.Ebene-1] >= Internal.ItemNrSoll[Internal.Ebene-1]) and (Internal.ArrayVariable = 0) and (Internal.ArrayStructure = 1) )then

					loop Internal.Ebene=Internal.Ebene-1 downto 0 do
							exitif((Internal.ItemNrIst[Internal.Ebene] < Internal.ItemNrSoll[Internal.Ebene]))
						endloop

						Internal.FoundChar= 0

						if Internal.Ebene <> 0 then
							loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
								SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamischen Variable setzen

								if ( (SearchChar = '.') and (Internal.Ebene-1 = Internal.FoundChar) )then
									SearchChar= 0
									Internal.ArrayStructure= 0
									exitif(1=1)
								else if ( (SearchChar = '[') and (Internal.Ebene-1 = Internal.FoundChar) )then
									SearchChar= 0
									strcat(adr(Internal.VarItemName),"[")						; add '[' ->testvariable[
									Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1	;increase dimension-counter
									itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
									strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index ->testvariable[0
									strcat(adr(Internal.VarItemName),"]")						; add ']' ->testvariable[0]
									Internal.ArrayStructure= 1
									exitif(1=1)
								else if	( (SearchChar = '[') and (Internal.Ebene > Internal.FoundChar) )then
									inc(Internal.FoundChar)		; eine weitere Ebene gefunden
								else if( (SearchChar = '.') and (Internal.Ebene > Internal.FoundChar) )then
									inc(Internal.FoundChar)		; eine weitere Ebene gefunden
								endif
							endloop
						else
							Internal.Ebene= 1
							loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
								if (SearchChar = '.') then
									SearchChar= 0
									exitif(1=1)
								endif
							endloop
							Internal.ArrayStructure= 0
							Internal.ArrayVariable = 0
					endif



	(*					strcat(adr(Internal.StrukturName),adr(Internal.ItemName))		; add the new item-name to the CSV-file
						loop Internal.i=Internal.Counter_Usint-1 downto 0 do
						SearchChar access adr(Internal.VarItemName) + Internal.i		; dynamic variable access
							if(	SearchChar = '.') then
								SearchChar= 0		; create new varible-name -> zerotermination of the string
													; with this zerotermination, the variable-name, witch was used at last for the
													; PV_ninfo()-function, will be cut off the last item-name
													; e.g.:	test.var1.var2 -> zerotemination -> test.var1

								exitif(1=1)			;exit loop
							endif
						endloop
						Internal.Ebene= Internal.Ebene - 2		; reduce level-counter
						Internal.ArrayStructure= 0				; reset flag for array-structure

						;******************************************************************************************
						; is the next structure also an array structure (e.g. test.var1.structure[0].struct[0].var2
						;******************************************************************************************
						if(Internal.ItemNrIst[Internal.Ebene] >= Internal.ItemNrSoll[Internal.Ebene])then

							SearchChar access adr(Internal.VarItemName) + Internal.i - 1		; dynamic variable access

							if( SearchChar = ']') then		; if the next characture = ']'
	;							##############################################
	; 							Correction from 10 September 2003
								if(Internal.ItemNrIst[Internal.Ebene-1] >= Internal.ItemNrSoll[Internal.Ebene-1])then	; es ist noch die richtige Ebene erreicht
									loop Internal.Ebene=Internal.Ebene-1 downto 0 do
										exitif((Internal.ItemNrIst[Internal.Ebene] < Internal.ItemNrSoll[Internal.Ebene]))
									endloop
									Internal.FoundChar= 0

									loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
										SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamischen Variable setzen

										if ( (SearchChar = '.') and (Internal.Ebene-1 = Internal.FoundChar) )then
											SearchChar= 0
											exitif(1=1)
										else if	( (SearchChar = '[') and (Internal.Ebene > Internal.FoundChar) )then
											inc(Internal.FoundChar)		; eine weitere Ebene gefunden
										else if( (SearchChar = '.') and (Internal.Ebene > Internal.FoundChar) )then
											inc(Internal.FoundChar)		; eine weitere Ebene gefunden
										endif
									endloop

								else
									loop Internal.i=Internal.i downto 0 do
										SearchChar access adr(Internal.VarItemName) + Internal.i		; dynamischen Variable setzen
										exitif(SearchChar = '[')
									endloop
									SearchChar= 0		; create new varible-name -> zerotermination of the string
														; with this zerotermination, the variable-name, witch was used at last for the
														; PV_ninfo()-function, will be cut off the last item-name
														; e.g.:	test.var1.var2 -> zerotemination -> test.var1
	; 								Correction from 10 September 2003
	;								##############################################
									strcat(adr(Internal.VarItemName),"[")						; add '[' ->testvariable[
									Internal.Ebene= Internal.Ebene-1	; reduce level-counter
									Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1	;increase dimension-counter
									itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
									strcat(adr(Internal.VarItemName),adr(Internal.Index))		; add index ->testvariable[0
									strcat(adr(Internal.VarItemName),"]")						; add ']' ->testvariable[0]
									Internal.ArrayStructure= 1									; set flag for array-structure
								endif
							endif
						endif
	*)
						exitif(1=1)			; exit loop

					; nur Array's-Variablen
					;******************************************************************************************
					; an array was found ( not in a structure)
					;******************************************************************************************
	 				else if( (SearchChar = '[') and (Internal.FoundChar = Internal.Ebene) and (Internal.Ebene = 1))then	; es ist noch die richtige Internal.Ebene erreicht
						strcat(adr(Internal.StrukturName),adr(Internal.VarItemName))	; add the new item-name to the CSV-file
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

						if(Internal.Ebene <> 0)then
							Internal.Ebene= Internal.Ebene - 1	; reduce level-counter
						else
							Internal.Ebene= 0					; reset counter
						endif
						Internal.ArrayVariable= 0				; reset flag for array-variable
						exitif(1=1)								; exit loop

					;******************************************************************************************
					; an array in a structure was found
					;******************************************************************************************
	 				else if( (SearchChar = '[') and (Internal.FoundChar = Internal.Ebene) and (Internal.Ebene > 1) )then
						loop Internal.i=Internal.Merker to  usint(strlen(adr(Internal.VarItemName)+1)) do	; loop the hole variable-name
							SearchChar access adr(Internal.VarItemName) + Internal.i		; dynamic variable access
							Internal.ArrayName[Internal.i-Internal.Merker]= SearchChar		; copy the last item-name
						endloop
						strcat(adr(Internal.StrukturName),adr(Internal.ArrayName))			; copy the last item-name to th CSV-file
						SearchChar access adr(Internal.VarItemName) + Internal.Merker-1		; dynamic variable access
						SearchChar= 0		; create new varible-name -> zerotermination of the string
											; with this zerotermination, the variable-name, witch was used at last for the
											; PV_ninfo()-function, will be cut off the last item-name
											; e.g.:	test.var1.var2 -> zerotemination -> test.var1

	;					###############################
	;					Correction from 17 July 2003
	;					if(Internal.Ebene <> 0)then
	;						Internal.Ebene= Internal.Ebene - 1	; reduce level-counter
	;					else
	;						Internal.Ebene= 0					; reset level-counter
	;					endif

						loop Internal.Ebene=Internal.Ebene-1 downto 0 do
							exitif((Internal.ItemNrIst[Internal.Ebene] < Internal.ItemNrSoll[Internal.Ebene]))
						endloop


						if(Internal.MerkerArray[Internal.Ebene]= 1)then
							Internal.FoundChar= 0
							loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
								SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamischen Variable setzen

								if ( (SearchChar = '[') and (Internal.Ebene-1 = Internal.FoundChar) )then
									SearchChar= 0
									Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1
									strcat(adr(Internal.VarItemName),"[")
									itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
									strcat(adr(Internal.VarItemName),adr(Internal.Index))
									strcat(adr(Internal.VarItemName),"]")
									Internal.NextItemReady= 1
									loop Internal.i=usint(strlen(adr(Internal.VarItemName)+1)) downto 0 do
										SearchChar access adr(Internal.VarItemName) + Internal.i		; dynamischen Variable setzen
										exitif(SearchChar='.')
									endloop

									if( Internal.i <> 0) then
										strcpy(adr(Internal.ItemName),adr(Internal.VarItemName) + Internal.i + 1)
									else
										strcpy(adr(Internal.ItemName),adr(Internal.VarItemName) + Internal.i)
									endif

									exitif(1=1)
								else if	( (SearchChar = '[') and (Internal.Ebene > Internal.FoundChar) )then
									inc(Internal.FoundChar)		; eine weitere Ebene gefunden
								else if( (SearchChar = '.') and (Internal.Ebene > Internal.FoundChar) )then
									inc(Internal.FoundChar)		; eine weitere Ebene gefunden
								endif
							endloop
						else
							Internal.FoundChar= 0
							loop Internal.Counter_Usint=0 to usint(strlen(adr(Internal.VarItemName)+1)) do			; den ganzen String durchsuchen
								SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint		; dynamischen Variable setzen

								if ( (SearchChar = '.') and (Internal.Ebene-1 = Internal.FoundChar) )then
									SearchChar= 0
									exitif(1=1)
								else if	( (SearchChar = '[') and (Internal.Ebene > Internal.FoundChar) )then
									inc(Internal.FoundChar)		; eine weitere Ebene gefunden
								else if( (SearchChar = '.') and (Internal.Ebene > Internal.FoundChar) )then
									inc(Internal.FoundChar)		; eine weitere Ebene gefunden
								endif
							endloop
						endif
	;					Correction from 17 July 2003
	;					###############################

						Internal.ArrayVariable= 0				; reset flag for array-variable
						exitif(1=1)
					;******************************************************************************************
					; a level was found, but not the right level
					;******************************************************************************************
					else if( ((SearchChar = '.') and (Internal.FoundChar < (Internal.Ebene-1))and (Internal.ArrayVariable = 0)) or ((SearchChar = '.') and (Internal.FoundChar < Internal.Ebene) and (Internal.ArrayVariable = 1)) )then	; es ist noch die richtige Internal.Ebene erreicht
	;					###############################
	;					Correction from 4 July 2003
						Internal.MerkerArray[Internal.FoundChar]= 0
	;					Correction from 4 July 2003
	;					###############################
						inc(Internal.FoundChar)						; increase counter for found levels
						Internal.Merker= Internal.Counter_Usint+1	; notice position of the found level-character
						Internal.ArrayStructure= 0					; reset flag for array-structure
					;******************************************************************************************
					; a level was found, but not the right level (array-structure)
					;******************************************************************************************
					else if ( (SearchChar = ']') and (Internal.Ebene > Internal.FoundChar) )then
	;					###############################
	;					Correction from 4 July 2003
						Internal.MerkerArray[Internal.FoundChar]= 1
	;					Correction from 4 July 2003
	;					###############################
						inc(Internal.FoundChar)			; increase counter for found levels
						Internal.ArrayStructure= 1		; set flag for array-structure
					endif
				endloop
				status= 65535
			next PV_DATATYP
		;##########################################################################################
		state PV_DATATYP
		;##########################################################################################

			if (FullNameLenght = 1) and (OnlyOneVar = 0) then
				strcpy( adr(Internal.StrukturName),adr(Internal.FullStrukturName) )
			endif

			when (Internal.Datatyp = 0) do
				strcat(adr(Internal.StrukturName),";STRUCTURE")			; add datatyp to CSV-file
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				Internal.ArrayStructure= 0
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 1) do
				strcat(adr(Internal.StrukturName),";BOOL;")				; add datatyp to CSV-file
				Dyn_Usint access Internal.PV_Adress
				itoa(Dyn_Usint,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+1
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 2) do
				strcat(adr(Internal.StrukturName),";SINT;")				; add datatyp to CSV-file
				Dyn_Sint access Internal.PV_Adress
				itoa(Dyn_Sint,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+3
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 3) do
				strcat(adr(Internal.StrukturName),";INT;")				; add datatyp to CSV-file
				Dyn_Int access Internal.PV_Adress
				itoa(Dyn_Int,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+6
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 4) do
				strcat(adr(Internal.StrukturName),";DINT;")				; add datatyp to CSV-file
				Dyn_Dint access Internal.PV_Adress
				itoa(Dyn_Dint,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+8
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 5) do
				strcat(adr(Internal.StrukturName),";USINT;")			; add datatyp to CSV-file
				Dyn_Usint access Internal.PV_Adress
				itoa(Dyn_Usint,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+3
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 6) do
				strcat(adr(Internal.StrukturName),";UINT;")				; add datatyp to CSV-file
				Dyn_Uint access Internal.PV_Adress
				itoa(Dyn_Uint,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+5
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 7) do
				strcat(adr(Internal.StrukturName),";UDINT;")			; add datatyp to CSV-file
				Dyn_Udint access Internal.PV_Adress
	;			itoa(Dyn_Udint,adr(Internal.Value))
				Internal.TmpValue = Dyn_Udint
				; umwandeln des UDINT-Werte in einen String
				Internal.Value[0]= usint(Internal.TmpValue/1000000000)+48;
				Internal.TmpValue= Internal.TmpValue mod 1000000000
				Internal.Value[1]= usint(Internal.TmpValue/100000000)+48;
				Internal.TmpValue= Internal.TmpValue mod 100000000
				Internal.Value[2]= usint(Internal.TmpValue/10000000)+48;
				Internal.TmpValue= Internal.TmpValue mod 10000000
				Internal.Value[3]= usint(Internal.TmpValue/1000000)+48;
				Internal.TmpValue= Internal.TmpValue mod 1000000
				Internal.Value[4]= usint(Internal.TmpValue/100000)+48;
				Internal.TmpValue= Internal.TmpValue mod 100000
				Internal.Value[5]= usint(Internal.TmpValue/10000)+48;
				Internal.TmpValue= Internal.TmpValue mod 10000
				Internal.Value[6]= usint(Internal.TmpValue/1000)+48;
				Internal.TmpValue= Internal.TmpValue mod 1000
				Internal.Value[7]= usint(Internal.TmpValue/100)+48;
				Internal.TmpValue= Internal.TmpValue mod 100
				Internal.Value[8]= usint(Internal.TmpValue/10)+48;
				Internal.TmpValue= Internal.TmpValue mod 10
				Internal.Value[9]= usint(Internal.TmpValue/1)+48;
				; angeführte nullen löschen
				loop Internal.i=0 to 9 do
					if(Internal.Value[Internal.i] <> '0') then
						memmove(adr(Internal.Value[0]),adr(Internal.Value[Internal.i]), sizeof(Internal.Value)-Internal.i)
						Internal.Value[sizeof(Internal.Value)-Internal.i] = 0
						exitif(1=1)
					endif
					; kein Wert
					if (Internal.i=9) then
						strcpy(adr(Internal.Value),"0")
					endif
				endloop
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+10
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 8) do
				strcat(adr(Internal.StrukturName),";REAL;")				; add datatyp to CSV-file
				Dyn_Real access Internal.PV_Adress
				ftoa(Dyn_Real,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				loop Internal.i=0 to sizeof(Internal.Value) do
					Dyn_Usint access adr(Internal.Value)+Internal.i
					exitif(Dyn_Usint = '.')
					if (Dyn_Usint = 0) then
						strcat(adr(Internal.StrukturName),".0")
						exitif(1=1)
					endif
				endloop
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				MemCounter= MemCounter+10
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 9) do
				strcat(adr(Internal.StrukturName),";STRING;")			; add datatyp to CSV-file

				;Internal.Lenght -> Länge der Variable

				MemCounter= MemCounter + Internal.Lenght + sizeof(Internal.CRLF[0])
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 10) do
				strcat(adr(Internal.StrukturName),";OCTET STRING;")		; add datatyp to CSV-file

				;Internal.Lenght -> Länge der Variable

				MemCounter= MemCounter + Internal.Lenght + sizeof(Internal.CRLF[0])
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 11) do
				strcat(adr(Internal.StrukturName),";DATE_AND_TIME;")	; add datatyp to CSV-file
				Dyn_Date_and_Time access Internal.PV_Adress
				ascDT(Dyn_Date_and_Time, adr(Internal.UsintArray), sizeof(Internal.UsintArray))
				strcat(adr(Internal.StrukturName),adr(Internal.UsintArray))		; add value to CSV-file
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 12) do
				strcat(adr(Internal.StrukturName),";TIME;")				; add datatyp to CSV-file
				Dyn_Time access Internal.PV_Adress
				Internal.DintTime= dint(Dyn_Time)
				itoa(Internal.DintTime,adr(Internal.Value))
				strcat(adr(Internal.StrukturName),adr(Internal.Value))	; add value to CSV-file
				strcat(adr(Internal.StrukturName),".0")
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				inc(Internal.VariableCounter)
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 13) or (Internal.Datatyp = 14) do
				status= 65535
			next COUNT_OFFSET

			when (Internal.Datatyp = 15) do
				strcat(adr(Internal.StrukturName),";ARRAY_OF_STRUCTURES")	; add datatyp to CSV-file
				strcat(adr(Internal.StrukturName),adr(Internal.CRLF[0]))
				status= 65535
			next COUNT_OFFSET

		;##########################################################################################
		state COUNT_OFFSET
		;##########################################################################################



			when (Internal.ArrayVariable = 0) and (Internal.ArrayStructure = 0) do
				MemCounter= MemCounter + strlen(adr(Internal.StrukturName))-1
				status= 65535
			next PV_ITEM_LOOP

			when(Internal.ArrayVariable= 1) do
				MemCounter= MemCounter + strlen(adr(Internal.StrukturName))-1
				strcpy(adr(Internal.StrukturName),"")

				loop Internal.i=0 to Internal.Ebene do
					strcat(adr(Internal.StrukturName),"     ")
				endloop
	    	strcat(adr(Internal.StrukturName),".")
	    	status= 65535
			next PV_ITEM_INFO

			when(Internal.ArrayStructure= 1) do
				MemCounter= MemCounter + strlen(adr(Internal.StrukturName))-1
				strcpy(adr(Internal.StrukturName),"")

				loop Internal.i=0 to Internal.Ebene do
					strcat(adr(Internal.StrukturName),"     ")
				endloop
	    	strcat(adr(Internal.StrukturName),".")
	    	status= 65535
			next PV_ITEM_INFO


		;##########################################################################################
		state PV_ITEM_LOOP
		;##########################################################################################

			; for part of structure: control, if this is the correct part
			when ( memcmp(adr(Internal.VarItemName), adr(Internal.StartVarName), strlen(adr(Internal.StartVarName))) <> 0) do
				status= 65535
			next ALLOC_MEMORY

			when(OnlyOneVar = 1)do
				OnlyOneVar= 0
				status= 65535
			next ALLOC_MEMORY

	;		###############################
	;		Correction from 4 July 2003

	;		Internal.PV_itemStatus = PV_item(adr(Internal.VarItemName), Internal.ItemNrIst[Internal.Ebene],adr(Internal.ItemName))

			if(Internal.NextItemReady = 0)then
				Internal.PV_itemStatus = PV_item(adr(Internal.VarItemName), Internal.ItemNrIst[Internal.Ebene],adr(Internal.ItemName))
			endif

			when (Internal.NextItemReady = 1) do
				strcpy(adr(Internal.StrukturName),"")
				loop Internal.i=0 to Internal.Ebene do
					strcat(adr(Internal.StrukturName),"     ")
				endloop
	    		strcat(adr(Internal.StrukturName),".")
				Internal.NextItemReady= 0
				status= 65535
			next PV_ITEM_INFO

	;		Correction from 4 July 2003
	;		###############################

			when ( strlen( adr(Internal.VarItemName)) + strlen( adr(Internal.ItemName)) ) > sizeof(Internal.VarItemName) do
				status= ERROR_STRUCT_NAMES
				ErrorName= Internal.NameCounter
			next WAIT

			when ((Internal.Ebene = 1) and (Internal.ItemNrIst[Internal.Ebene] >= Internal.ItemNrSoll[Internal.Ebene])) or (Internal.Ebene = 0) do
				Internal.PV_itemStatus = 0
				status= 65535
			next ALLOC_MEMORY


			when (Internal.PV_itemStatus = 14714) and (Internal.ArrayStructure = 1) do
				Internal.PV_itemStatus = 0
				status= 65535
			next ALLOC_MEMORY

			when (Internal.Ebene > 1) and (Internal.PV_itemStatus <> 0) and (Internal.ItemNrIst[Internal.Ebene] = Internal.ItemNrSoll[Internal.Ebene]) do
				loop Internal.Counter_Usint= usint(strlen(adr(Internal.VarItemName)+1)) downto 0 do
					SearchChar access adr(Internal.VarItemName) + Internal.Counter_Usint

					if ( SearchChar = '.' ) then
						SearchChar= 0
						Internal.Ebene= Internal.Ebene-1
						if (Internal.ItemNrIst[Internal.Ebene] <> Internal.ItemNrSoll[Internal.Ebene]) then
							exitif(1=1)
						endif
					endif

					if ( SearchChar = '[' ) then
						SearchChar= 0
						Internal.Ebene= Internal.Ebene-1
						if (Internal.ItemNrIst[Internal.Ebene] <> Internal.ItemNrSoll[Internal.Ebene]) then
							Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene]+1
							strcat(adr(Internal.VarItemName),"[")
							itoa(Internal.ItemNrIst[Internal.Ebene],adr(Internal.Index))
							strcat(adr(Internal.VarItemName),adr(Internal.Index))
							strcat(adr(Internal.VarItemName),"]")
							Internal.NextItemReady= 1
							exitif(1=1)
						endif
					endif

				endloop
				status= 65535
			next PV_ITEM_LOOP

			when (Internal.PV_itemStatus = 0) do
				strcat(adr(Internal.VarItemName),".")
				strcat(adr(Internal.VarItemName),adr(Internal.ItemName))
				Internal.ItemNrIst[Internal.Ebene]= Internal.ItemNrIst[Internal.Ebene] + 1
				strcpy(adr(Internal.StrukturName),"")

				loop Internal.i=0 to Internal.Ebene do
					strcat(adr(Internal.StrukturName),"     ")
				endloop
	    		strcat(adr(Internal.StrukturName),".")
				status= 65535
			next PV_ITEM_INFO


			when (Internal.PV_itemStatus <> 0) do	; any error ocurred
				status= Internal.PV_itemStatus		; return error-code
				ErrorName= Internal.NameCounter
			next WAIT

		;##########################################################################################
		state ALLOC_MEMORY
		;##########################################################################################
			Dyn_Udint access (pStructName + Internal.NameCounter*4 )

			when (Internal.NameCounter < NumOfStructs) and (NumOfStructs > 1) and (Dyn_Udint <> 0) do

				Internal.Ebene= 1	;Start-Level
				MemCounter= MemCounter + 440     ;Maximum-Size of the Header
				OnlyOneVar= 0

				loop Internal.i=0 to 49 do
					Internal.ItemNrSoll[Internal.i]= 65535	;set and reset internal counter
					Internal.ItemNrIst[Internal.i]= 0
				endloop
				; Carriage Return and Linefeed
				Internal.CRLF[0]= 13
				Internal.CRLF[1]= 10
				Internal.CRLF[2]= 0		; String Zerotermination

				strcpy(adr(Internal.VarItemName), Dyn_Udint)	;copy Structurename to Internal "Work"-String
				loop Internal.i=usint(strlen(adr(Internal.VarItemName))) downto 0 do
					SearchChar access adr(Internal.VarItemName) + Internal.i	; set dynamic variable for access
						if (SearchChar = '.')then
							Internal.ItemNrSoll[Internal.Ebene]= 1
							Internal.ItemNrIst[Internal.Ebene]= 1
							Internal.Ebene= Internal.Ebene+1
						else if(SearchChar = '[') then
							Internal.ItemNrSoll[Internal.Ebene]= 1
							Internal.ItemNrIst[Internal.Ebene]= 1
							Internal.Ebene= Internal.Ebene+1
						endif
				endloop
				Internal.NameCounter= Internal.NameCounter+1
				status= 65535
			next PV_INFO

			when (NumOfStructs = 0) or (NumOfStructs = 1) or (Internal.NameCounter = NumOfStructs) do
				Internal.TMP_allocStatus= TMP_alloc(MemCounter, adr(pStructMem) )
				status= 0
				exitif(1=1)		; exit endless loop
			next WAIT


			when (Dyn_Udint = 0 ) do
				status= ERROR_STRUCT_NAMES
				ErrorName= Internal.NameCounter
			next WAIT

		;##########################################################################################
		state WAIT
		;##########################################################################################
			exitif(1=1)		; exit endless loop
			when (1=1) do
			next WAIT


	endselect

		exitif(status<>65535)
	endloop
else
    status = ERROR_INPUT_POINTER_ERR;
endif
END_FUNCTION_BLOCK
